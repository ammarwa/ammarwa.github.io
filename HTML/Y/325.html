<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>buffer</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/26.html#L26'>buffer</a>             26 llvm_tool/lib/fluxDevicePass.cpp   std::array&lt;char, 128&gt; buffer;</span>
<span class='curline'><a href='../S/26.html#L32'>buffer</a>             32 llvm_tool/lib/fluxDevicePass.cpp     if (fgets(buffer.data(), 128, pipe.get()) != nullptr)</span>
<span class='curline'><a href='../S/26.html#L33'>buffer</a>             33 llvm_tool/lib/fluxDevicePass.cpp       result += buffer.data();</span>
<span class='curline'><a href='../S/24.html#L54'>buffer</a>             54 llvm_tool/lib/fluxHostPass.cpp   std::string buffer(size, '\0');</span>
<span class='curline'><a href='../S/24.html#L55'>buffer</a>             55 llvm_tool/lib/fluxHostPass.cpp   assert(file.read(&amp;buffer[0], size));</span>
<span class='curline'><a href='../S/24.html#L61'>buffer</a>             61 llvm_tool/lib/fluxHostPass.cpp   while ((pos_end = buffer.find("\n", pos)) != std::string::npos) {</span>
<span class='curline'><a href='../S/24.html#L62'>buffer</a>             62 llvm_tool/lib/fluxHostPass.cpp     lines.push_back(buffer.substr(pos, pos_end - pos));</span>
<span class='curline'><a href='../S/24.html#L107'>buffer</a>            107 llvm_tool/lib/fluxHostPass.cpp   Value *analysisStr = mekong::createGlobalStringPtr(M, StringRef(buffer));</span>
<span class='curline'><a href='../S/10.html#L76'>buffer</a>             76 llvm_tool/mekong-utils/inc/ptx_parser.h   std::string buffer(size, '\0');</span>
<span class='curline'><a href='../S/10.html#L77'>buffer</a>             77 llvm_tool/mekong-utils/inc/ptx_parser.h   if (!file.read(&amp;buffer[0], size))</span>
<span class='curline'><a href='../S/10.html#L87'>buffer</a>             87 llvm_tool/mekong-utils/inc/ptx_parser.h   input_t input(buffer.c_str());</span>
<span class='curline'><a href='../S/5.html#L33'>buffer</a>             33 llvm_tool/mekong-utils/src/IRUtils.cpp   std::string buffer(size, '\0');</span>
<span class='curline'><a href='../S/5.html#L34'>buffer</a>             34 llvm_tool/mekong-utils/src/IRUtils.cpp   assert(file.read(&amp;buffer[0], size &amp;&amp; "Could not read file!"));</span>
<span class='curline'><a href='../S/5.html#L36'>buffer</a>             36 llvm_tool/mekong-utils/src/IRUtils.cpp   auto hash = generateHash(buffer.c_str(), size);</span>
<span class='curline'><a href='../S/616.html#L300'>buffer</a>            300 reuse_distance_tool/parda.c 	void** buffer = (void**)malloc(buffersize * sizeof(void*));</span>
<span class='curline'><a href='../S/616.html#L302'>buffer</a>            302 reuse_distance_tool/parda.c 		count = fread(buffer, sizeof(void*), buffersize, fp);</span>
<span class='curline'><a href='../S/616.html#L304'>buffer</a>            304 reuse_distance_tool/parda.c 			sprintf(inst_id, mem_id, warp_id, address, "%p %p %p %p", buffer[i]);</span>
<span class='curline'><a href='../S/619.html#L52'>buffer</a>             52 reuse_distance_tool/seperate.c   void** buffer = (void**)malloc(buffersize * sizeof(void*));</span>
<span class='curline'><a href='../S/619.html#L59'>buffer</a>             59 reuse_distance_tool/seperate.c       count = fread(buffer, sizeof(void*), count, fp);</span>
<span class='curline'><a href='../S/619.html#L60'>buffer</a>             60 reuse_distance_tool/seperate.c       fwrite(buffer, sizeof(void*), count, fw);</span>
</pre>
</body>
</html>
