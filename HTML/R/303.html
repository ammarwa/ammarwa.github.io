<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>mekong</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/26.html#L38'>mekong</a>             38 llvm_tool/lib/fluxDevicePass.cpp std::vector&lt;mekong::PTXFunction&gt; ptxInstructionAnalysis(Module &amp;M) {</span>
<span class='curline'><a href='../S/26.html#L40'>mekong</a>             40 llvm_tool/lib/fluxDevicePass.cpp   std::string prefix = mekong::getModulePrefix(&amp;M);</span>
<span class='curline'><a href='../S/26.html#L46'>mekong</a>             46 llvm_tool/lib/fluxDevicePass.cpp   mekong::dumpModuleToFile(M, byteCodeFile);</span>
<span class='curline'><a href='../S/26.html#L52'>mekong</a>             52 llvm_tool/lib/fluxDevicePass.cpp   mekong::getKernels(M, kernels);</span>
<span class='curline'><a href='../S/26.html#L69'>mekong</a>             69 llvm_tool/lib/fluxDevicePass.cpp   auto tokenVec = mekong::lexicalAnalysis(ptxFile);</span>
<span class='curline'><a href='../S/26.html#L70'>mekong</a>             70 llvm_tool/lib/fluxDevicePass.cpp   auto funcVec = mekong::parse(tokenVec);</span>
<span class='curline'><a href='../S/26.html#L108'>mekong</a>            108 llvm_tool/lib/fluxDevicePass.cpp void basicBlockInstrumentation(Module &amp;M, std::vector&lt;mekong::PTXFunction&gt; funcVec) {</span>
<span class='curline'><a href='../S/26.html#L117'>mekong</a>            117 llvm_tool/lib/fluxDevicePass.cpp   mekong::getKernels(M, kernels);</span>
<span class='curline'><a href='../S/26.html#L135'>mekong</a>            135 llvm_tool/lib/fluxDevicePass.cpp     Function *kernelClone = mekong::cloneAndAddArgs(kernel, args, {"bblist", "bblist1", "n_banks", "profiling_mode"});</span>
<span class='curline'><a href='../S/26.html#L140'>mekong</a>            140 llvm_tool/lib/fluxDevicePass.cpp     std::map&lt;BasicBlock *, int&gt; blockIDs = mekong::getBlockIDMap(kernelClone, funcVec, kernel-&gt;getName().str());</span>
<span class='curline'><a href='../S/26.html#L176'>mekong</a>            176 llvm_tool/lib/fluxDevicePass.cpp     mekong::markKernel(M, kernelClone);</span>
<span class='curline'><a href='../S/26.html#L196'>mekong</a>            196 llvm_tool/lib/fluxDevicePass.cpp   mekong::getKernels(M, kernels);</span>
<span class='curline'><a href='../S/26.html#L234'>mekong</a>            234 llvm_tool/lib/fluxDevicePass.cpp   mekong::linkIR(deviceRuntime, M);</span>
<span class='curline'><a href='../S/24.html#L39'>mekong</a>             39 llvm_tool/lib/fluxHostPass.cpp   mekong::linkIR(hostRuntime, M);</span>
<span class='curline'><a href='../S/24.html#L42'>mekong</a>             42 llvm_tool/lib/fluxHostPass.cpp   std::string prefix = mekong::getModulePrefix(&amp;M);</span>
<span class='curline'><a href='../S/24.html#L107'>mekong</a>            107 llvm_tool/lib/fluxHostPass.cpp   Value *analysisStr = mekong::createGlobalStringPtr(M, StringRef(buffer));</span>
<span class='curline'><a href='../S/24.html#L118'>mekong</a>            118 llvm_tool/lib/fluxHostPass.cpp   std::vector&lt;mekong::KernelDescriptor&gt; descs;</span>
<span class='curline'><a href='../S/24.html#L119'>mekong</a>            119 llvm_tool/lib/fluxHostPass.cpp   mekong::getKernelDescriptors(M, descs);</span>
<span class='curline'><a href='../S/24.html#L147'>mekong</a>            147 llvm_tool/lib/fluxHostPass.cpp     Function *clonedKernelWrapper = mekong::createKernelWrapper(M, cloneName, cloneType);</span>
<span class='curline'><a href='../S/24.html#L149'>mekong</a>            149 llvm_tool/lib/fluxHostPass.cpp     mekong::registerKernel(M, cloneName, clonedKernelWrapper);</span>
<span class='curline'><a href='../S/24.html#L152'>mekong</a>            152 llvm_tool/lib/fluxHostPass.cpp     mekong::getKernelLaunchSites(desc.handle, launchSites);</span>
<span class='curline'><a href='../S/24.html#L155'>mekong</a>            155 llvm_tool/lib/fluxHostPass.cpp       CallBase *confCall = mekong::getKernelConfigCall(M, launch);</span>
<span class='curline'><a href='../S/24.html#L206'>mekong</a>            206 llvm_tool/lib/fluxHostPass.cpp       CallBase *cloneLaunchCall = mekong::replaceKernelLaunch(M, launch, clonedKernelWrapper, additionalArgs);</span>
<span class='curline'><a href='../S/16.html#L6'>mekong</a>              6 llvm_tool/mekong-utils/inc/BasicBlockEnumerator.h namespace mekong {</span>
<span class='curline'><a href='../S/12.html#L10'>mekong</a>             10 llvm_tool/mekong-utils/inc/DeviceUtils.h namespace mekong {</span>
<span class='curline'><a href='../S/15.html#L8'>mekong</a>              8 llvm_tool/mekong-utils/inc/HostUtils.h namespace mekong {</span>
<span class='curline'><a href='../S/17.html#L21'>mekong</a>             21 llvm_tool/mekong-utils/inc/IRUtils.h namespace mekong {</span>
<span class='curline'><a href='../S/17.html#L29'>mekong</a>             29 llvm_tool/mekong-utils/inc/IRUtils.h getBlockIDMap(llvm::Function *func, std::vector&lt;mekong::PTXFunction&gt; funcVec,</span>
<span class='curline'><a href='../S/9.html#L7'>mekong</a>              7 llvm_tool/mekong-utils/inc/PTXFunction.h namespace mekong {</span>
<span class='curline'><a href='../S/10.html#L16'>mekong</a>             16 llvm_tool/mekong-utils/inc/ptx_parser.h namespace mekong {</span>
<span class='curline'><a href='../S/5.html#L44'>mekong</a>             44 llvm_tool/mekong-utils/src/IRUtils.cpp getBlockIDMap(llvm::Function *func, std::vector&lt;mekong::PTXFunction&gt; funcVec,</span>
</pre>
</body>
</html>
